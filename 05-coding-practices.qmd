# R Coding Practices {#sec-r-coding-practices}

## Lab Protocols for Code and Data

Just as wet labs have strict safety protocols to ensure reproducible results and prevent contamination, our computational lab has protocols for coding and data management. These protocols are not suggestions—they are essential practices that:

- **Ensure reproducibility**: Others (including your future self) can recreate your analysis
- **Prevent errors**: Systematic approaches reduce the risk of mistakes
- **Enable collaboration**: Consistent practices allow team members to work together efficiently
- **Maintain data integrity**: Proper handling prevents data corruption and loss
- **Support publication**: Well-documented, reproducible code is increasingly required for publication

**Violating these protocols can have serious consequences**, including invalid results, wasted time, inability to publish, and damage to scientific credibility. Treat coding and data management protocols with the same seriousness as you would safety protocols in a wet lab.

## Essential R Package Development Tools {#sec-r-package-tools}

The following tools are essential for R package development in our lab:

### usethis: Package Setup and Management

`usethis` automates common package development tasks:

```r
# Install usethis
install.packages("usethis")

# Create a new package
usethis::create_package("~/myproject")

# Add common components
usethis::use_mit_license()          # Add a license
usethis::use_git()                  # Initialize git
usethis::use_github()               # Connect to GitHub
usethis::use_testthat()             # Set up testing infrastructure
usethis::use_vignette("intro")      # Create a vignette (shipped with package)
usethis::use_article("case-study")  # Create an article (website-only)
usethis::use_data_raw("dataset")    # Create data processing script
usethis::use_package("dplyr")       # Add a dependency
usethis::use_pipe()                 # Import pipe operator

# Increment version
usethis::use_version()              # Increment package version
```

### devtools: Development Workflow

`devtools` provides the core development workflow:

```r
# Install devtools
install.packages("devtools")

# Load your package for interactive development
devtools::load_all()                # Like library(), but for development

# Documentation
devtools::document()                # Generate documentation from roxygen2

# Testing
devtools::test()                    # Run all tests
devtools::test_active_file()        # Run tests in current file

# Checking
devtools::check()                   # R CMD check (comprehensive validation)
devtools::check_man()               # Check documentation only

# Dependencies
devtools::install_dev_deps()        # Install all development dependencies

# Building
devtools::build()                   # Build package bundle
devtools::install()                 # Install package locally
```

### pkgdown: Package Websites

`pkgdown` builds beautiful documentation websites from your package:

```r
# Install pkgdown
install.packages("pkgdown")

# Set up pkgdown
usethis::use_pkgdown()

# Build website locally
pkgdown::build_site()

# Preview in browser
pkgdown::build_site(preview = TRUE)

# Build components separately
pkgdown::build_reference()          # Function reference
pkgdown::build_articles()           # Vignettes
pkgdown::build_home()               # Home page from README
```

**Configure your pkgdown site** with `_pkgdown.yml`:

```yaml
url: https://ucd-serg.github.io/myproject

template:
  bootstrap: 5

reference:
  - title: "Data Preparation"
    desc: "Functions for preparing and cleaning data"
    contents:
    - prep_study_data
    - validate_data
  
  - title: "Analysis"
    desc: "Core analysis functions"
    contents:
    - run_primary_analysis
    - sensitivity_analysis

articles:
  - title: "Analysis Workflow"
    navbar: Analysis
    contents:
    - 01-data-preparation
    - 02-primary-analysis
    - 03-sensitivity-analysis
```

## Complete Package Development Workflow {#sec-r-workflow}

Here's the typical workflow for developing an R package in our lab:

### 1. Initial Setup

```r
# Create package structure
usethis::create_package("~/myproject")

# Set up infrastructure
usethis::use_git()
usethis::use_github()
usethis::use_testthat()
usethis::use_pkgdown()
usethis::use_mit_license()
usethis::use_readme_rmd()
```

### 2. Add Dependencies

```r
# Add packages your project depends on
usethis::use_package("dplyr")
usethis::use_package("ggplot2")
usethis::use_package("readr")

# Add packages only needed for development/testing
usethis::use_package("testthat", type = "Suggests")
```

### 3. Write Functions

Create functions in `R/` directory with roxygen2 documentation:

```r
#' Prepare Study Data
#'
#' Clean and prepare raw study data for analysis.
#'
#' @param raw_data A data frame containing raw study data
#' @param validate Logical; whether to run validation checks
#'
#' @returns A cleaned data frame ready for analysis
#'
#' @examples
#' raw_data <- read_csv("data.csv")
#' clean_data <- prep_study_data(raw_data)
#'
#' @export
prep_study_data <- function(raw_data, validate = TRUE) {
  # Function implementation
}
```

### 4. Document

```r
# Generate documentation from roxygen2 comments
devtools::document()
```

### 5. Test

Create tests in `tests/testthat/`:

```r
# tests/testthat/test-data_prep.R
test_that("prep_study_data handles missing values", {
  raw_data <- data.frame(x = c(1, NA, 3))
  result <- prep_study_data(raw_data)
  expect_false(anyNA(result$x))
})
```

Run tests:

```r
devtools::test()
```

### 6. Check

```r
# Comprehensive package check
devtools::check()
```

Fix any warnings or errors before proceeding.

### 7. Build Documentation Site

```r
pkgdown::build_site()
```

### 8. Share and Publish

```r
# Push to GitHub
# The pkgdown site can be automatically deployed to GitHub Pages
# using GitHub Actions
```
```

## Testing Requirements {#sec-r-testing}

**ALWAYS establish tests BEFORE modifying functions.** This ensures changes preserve existing behavior and new behavior is correctly validated.

### When to Use Snapshot Tests

Use snapshot tests (`expect_snapshot()`, `expect_snapshot_value()`) when:

- Testing complex data structures (data frames, lists, model outputs)
- Validating statistical results where exact values may vary slightly
- Output format stability is important

```r
test_that("prep_study_data produces expected structure", {
  result <- prep_study_data(raw_data)
  expect_snapshot_value(result, style = "serialize")
})
```

### When to Use Explicit Value Tests

Use explicit tests (`expect_equal()`, `expect_identical()`) when:

- Testing simple scalar outputs
- Validating specific numeric thresholds
- Testing Boolean returns or categorical outputs

```r
test_that("calculate_mean returns correct value", {
  expect_equal(calculate_mean(c(1, 2, 3)), 2)
  expect_equal(calculate_ratio(3, 7), 0.4285714, tolerance = 1e-6)
})
```

### Testing Best Practices

- **Seed randomness**: Use `withr::local_seed()` for reproducible tests
- **Use small test cases**: Keep tests fast
- **Test edge cases**: Missing values, empty inputs, boundary conditions
- **Test errors**: Verify functions fail appropriately with invalid input

```r
test_that("prep_study_data handles edge cases", {
  # Empty input
  expect_error(prep_study_data(data.frame()))
  
  # Missing required columns
  expect_error(prep_study_data(data.frame(x = 1)))
  
  # Valid input with missing values
  result <- prep_study_data(data.frame(id = 1:3, value = c(1, NA, 3)))
  expect_true(all(!is.na(result$value)))
})
```

## Iterative Operations {#sec-iteration}

When applying analyses with different variations (outcomes, exposures, subgroups), use functional programming approaches:

### `lapply()` and `sapply()`

```r
# Apply function to each element
results <- lapply(outcomes, function(y) {
  run_analysis(data, outcome = y)
})

# Simplify to vector if possible
summary_stats <- sapply(data_list, mean)
```

### `purrr::map()` Family

The `purrr` package provides type-stable alternatives:

```r
library(purrr)

# Always returns a list
results <- map(outcomes, ~ run_analysis(data, outcome = .x))

# Type-specific variants
means <- map_dbl(data_list, mean)        # Returns numeric vector
models <- map(splits, ~ lm(y ~ x, data = .x))  # Returns list of models
```

### `purrr::pmap()` for Multiple Arguments

When iterating over multiple parameter lists:

```r
params <- tibble(
  outcome = c("outcome1", "outcome2", "outcome3"),
  exposure = c("exp1", "exp2", "exp3"),
  covariate_set = list(c("age", "sex"), c("age"), c("age", "sex", "bmi"))
)

results <- pmap(params, function(outcome, exposure, covariate_set) {
  run_analysis(
    data = study_data,
    outcome = outcome,
    exposure = exposure,
    covariates = covariate_set
  )
})
```

### Parallel Processing

For computationally intensive work, use `future` and `furrr`:

```r
library(future)
library(furrr)

# Set up parallel processing
plan(multisession, workers = availableCores() - 1)

# Parallel version of map()
results <- future_map(large_list, time_consuming_function, .progress = TRUE)
```

## Reading and Saving Data {#sec-data-io}

### RDS Files (Preferred)

Use RDS format for R objects:

```r
# Save single object
readr::write_rds(analysis_results, here("results", "analysis.rds"))

# Read back
results <- readr::read_rds(here("results", "analysis.rds"))
```

**Avoid `.RData` files** because:
- You can't control object names when loading
- Can't load individual objects
- Creates confusion in older code

### CSV Files

For tabular data that may be shared with non-R users:

```r
# Write
readr::write_csv(data, here("data-raw", "clean_data.csv"))

# Read
data <- readr::read_csv(here("data-raw", "clean_data.csv"))

# For very large files, use data.table
data.table::fwrite(large_data, "big_file.csv")
data <- data.table::fread("big_file.csv")
```

## Version Control and Collaboration {#sec-r-version-control}

### Version Numbers

Follow semantic versioning (MAJOR.MINOR.PATCH):

- Development versions: `0.0.0.9000`, `0.0.0.9001`, etc.
- First release: `0.1.0`
- Bug fixes: increment PATCH (e.g., `0.1.0` → `0.1.1`)
- New features: increment MINOR (e.g., `0.1.1` → `0.2.0`)
- Breaking changes: increment MAJOR (e.g., `0.2.0` → `1.0.0`)

```r
# Increment version
usethis::use_version()
```

### NEWS File

Document all user-facing changes in `NEWS.md`:

```markdown
# myproject 0.2.0

## New Features

* Added `prep_study_data()` function for data preparation
* Implemented sensitivity analysis in `sensitivity_analysis()`

## Bug Fixes

* Fixed handling of missing values in `calculate_mean()`

## Breaking Changes

* Renamed `old_function()` to `new_function()`
```

### Git Workflow

```r
# Set up Git and GitHub
usethis::use_git()
usethis::use_github()

# Before committing changes
devtools::document()        # Update documentation
devtools::test()            # Run tests
devtools::check()           # Full package check
```

### Managing Dependencies with renv {#sec-renv}

**Use `renv` to tightly control dependency versions during development.** The `renv` package creates a project-specific library that isolates your package dependencies, ensuring reproducibility across different machines and over time.

#### When to Use renv

- **During active development**: Use `renv` to lock down specific versions of dependencies
- **For collaborative projects**: Ensure all team members use the same package versions
- **For long-term reproducibility**: Preserve the exact dependency environment

#### Setting Up renv

```r
# Install renv
install.packages("renv")

# Initialize renv in your package
renv::init()

# This creates:
# - renv/ directory with package library
# - renv.lock file with exact package versions
# - .Rprofile to activate renv on startup
```

#### Using renv in Package Development

```r
# Install/update packages (renv tracks changes)
install.packages("dplyr")
renv::install("tidyr@1.3.0")  # Install specific version

# Save the current state
renv::snapshot()

# Restore packages from lockfile
renv::restore()

# Update packages
renv::update()
```

#### Preparing for CRAN Release

**For packages ready for CRAN submission, disable renv and test with latest dependency versions:**

1. **Remove renv** before CRAN submission:
   ```r
   renv::deactivate()
   # Delete renv/ directory and renv.lock
   # Remove .Rprofile modifications
   ```

2. **Test with latest versions**:
   ```r
   # Install latest versions of all dependencies
   devtools::install_dev_deps()
   
   # Run comprehensive checks
   devtools::check()
   ```

3. **Why disable renv for CRAN**: CRAN tests packages against the latest versions of dependencies. Your package should work with current CRAN versions, not pinned older versions.

**Workflow summary:**

- **Development phase**: Use `renv` for stability and reproducibility
- **Pre-CRAN release**: Disable `renv`, test with latest dependency versions
- **After CRAN release**: Can re-enable `renv` for continued development if desired

#### Additional Resources

For comprehensive guidance on using renv with R packages, see:
- [Using renv with R Packages](https://rstudio.github.io/renv/articles/packages.html)
- [renv documentation](https://rstudio.github.io/renv/)

- [ ] All changes committed and pushed to GitHub

## Continuous Integration {#sec-r-ci}

Set up automated checks using GitHub Actions:

```r
# Add standard R package CI workflows
usethis::use_github_action("check-standard")    # R CMD check
usethis::use_github_action("test-coverage")     # Code coverage
usethis::use_github_action("pkgdown")           # Deploy website
```

These workflows automatically:


- Run R CMD check on multiple platforms (Linux, macOS, Windows)
- Calculate test coverage
- Build and deploy your pkgdown website
- Ensure code quality before merging

## Quality Assurance Checklist {#sec-r-qa-checklist}

Before submitting a pull request or finalizing analysis, verify:

- [ ] All functions have complete roxygen2 documentation
- [ ] All functions have corresponding tests
- [ ] `devtools::document()` has been run
- [ ] `devtools::test()` passes with no failures
- [ ] `devtools::check()` passes with no errors, warnings, or notes
- [ ] `lintr::lint_package()` shows no issues (or only acceptable ones)
- [ ] `spelling::spell_check_package()` passes
- [ ] Version number has been incremented
- [ ] `NEWS.md` has been updated with changes
- [ ] `README.Rmd` has been updated (if needed) and `README.md` regenerated
- [ ] `pkgdown::build_site()` builds successfully
- [ ] All changes committed and pushed to GitHub

## Automated Code Styling {#sec-auto-styling}

### RStudio Built-in Formatting

Use RStudio's built-in autoformatter (keyboard shortcut: `CMD-Shift-A` or `Ctrl-Shift-A`) to quickly format highlighted code.

### styler Package

For automated styling of entire projects:

```r
# Install styler
install.packages("styler")

# Style all files in R/ directory
styler::style_dir("R/")

# Style entire package
styler::style_pkg()

# Note: styler modifies files in-place
# Always use with version control so you can review changes
```

### lintr Package

For checking code style without modifying files:

```r
# Install lintr
install.packages("lintr")

# Lint the entire package
lintr::lint_package()

# Lint a specific file
lintr::lint("R/my_function.R")
```

The linter checks for:
- Unused variables
- Improper whitespace
- Line length issues
- Style guide violations

You can customize linting rules by creating a `.lintr` file in your project root.

## Additional Resources {#sec-r-resources}

- [R Packages book](https://r-pkgs.org/) by Hadley Wickham and Jenny Bryan
- [Tidyverse style guide](https://style.tidyverse.org/)
- [usethis documentation](https://usethis.r-lib.org/)
- [devtools documentation](https://devtools.r-lib.org/)
- [pkgdown documentation](https://pkgdown.r-lib.org/)
- [testthat documentation](https://testthat.r-lib.org/)
