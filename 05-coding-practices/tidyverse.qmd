
Throughout this document there have been references to the Tidyverse, but this section is to explicitly show you how to transform your Base R tendencies to Tidyverse (or Data.Table, Tidyverse's performance-optimized competitor). For most of our work that does not utilize very large datasets, we recommend that you code in Tidyverse rather than Base R. Tidyverse is quickly becoming [the gold standard](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/) in R data analysis and modern data science packages and code should use Tidyverse style and packages unless there's a significant reason not to (i.e. big data pipelines that would benefit from Data.Table's performance optimizations).

The package author has published a [great textbook on R for Data Science](https://r4ds.had.co.nz/), which leans heavily on many Tidyverse packages and may be worth checking out.

The following list is not exhaustive, but is a compact overview to begin to translate Base R into something better:

Base R | Better Style, Performance, and Utility
--- | ---
_|_
`read.csv()`| `readr::read_csv()` or `data.table::fread()`
`write.csv()` | `readr::write_csv()` or `data.table::fwrite()`
`readRDS` | `readr::read_rds()`
`saveRDS()` | `readr::write_rds()`
_|_
`data.frame()` | `tibble::tibble()` or `tibble::tribble()`
`rbind()` | `dplyr::bind_rows()`
`cbind()` | `dplyr::bind_cols()`
`df$some_column` | `df |> dplyr::pull(some_column)`
`df$some_column = ...` | `df |> dplyr::mutate(some_column = ...)`
`df[get_rows_condition,]` | `df |> dplyr::filter(get_rows_condition)`
`df[,c(col1, col2)]` | `df |> dplyr::select(col1, col2)`
`merge(df1, df2, by = ..., all.x = ..., all.y = ...)` | `df1 |> dplyr::left_join(df2, by = ...)` or `dplyr::full_join` or `dplyr::inner_join` or `dplyr::right_join`
_|_
`str()` | `dplyr::glimpse()`
`grep(pattern, x)` | `stringr::str_which(string, pattern)`
`gsub(pattern, replacement, x)` | `stringr::str_replace(string, pattern, replacement)`
`ifelse(test_expression, yes, no)`| `if_else(condition, true, false)`
Nested: `ifelse(test_expression1, yes1, ifelse(test_expression2, yes2, ifelse(test_expression3, yes3, no)))` | `case_when(test_expression1 ~ yes1,  test_expression2 ~ yes2, test_expression3 ~ yes3, TRUE ~ no)`
`proc.time()` | `tictoc::tic()` and `tictoc::toc()`
`stopifnot()` | `assertthat::assert_that()` or `assertthat::see_if()` or `assertthat::validate_that()`
_|_
`sessionInfo()` | `sessioninfo::session_info()`

For a more extensive set of syntactical translations to Tidyverse, you can check out [this document](https://tavareshugo.github.io/data_carpentry_extras/base-r_tidyverse_equivalents/base-r_tidyverse_equivalents.html#reshaping_data).


Working with Tidyverse within functions can be somewhat of a pain due to non-standard evaluation (NSE) semantics. If you're an avid function writer, we'd recommend checking out the following resources:

- [Tidy Eval in 5 Minutes](https://www.youtube.com/watch?v=nERXS3ssntw) (video)
- [Tidy Evaluation](https://tidyeval.tidyverse.org/index.html) (e-book)
- [Data Frame Columns as Arguments to Dplyr Functions](https://www.brodrigues.co/blog/2016-07-18-data-frame-columns-as-arguments-to-dplyr-functions/) (blog)
- [Standard Evaluation for *_join](https://stackoverflow.com/questions/28125816/r-standard-evaluation-for-join-dplyr) (stackoverflow)
- [Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html) (package vignette)

::: callout-tip

#### sho
